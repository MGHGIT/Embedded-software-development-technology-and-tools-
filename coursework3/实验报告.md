# 嵌入式软件开发与工具实验报告

## 多线程编程

第一组 组员：李普，李娟，卢意

### 一、实验目的

1、掌握基于pthread线程库的多线程编程技术；

2、掌握基本的线程间同步技术（sem,mutex）；

3、理解共享资源并掌握其操作方法。

### 二、实验内容

读者-写者问题多线程实现：
- 一个数据集（如数据、文件等）被N个线程读写；

- 一些线程只要求读数据集内容，称为读者，实验读者数不少于6个；

- 另些线程要求修改数据集内容，称为写者，实验写者数不少于3个；

- 多个读者同时读数据内容，不需要互斥操作；

- 一个写者不能和其他写者或读者同时访问数据集，换句话说，写者和其他写者或读者之间必须互斥操作！

- 读者优先：如果有读者，写者需要等待！用于更新不频繁或更新影响不显著、读者较多的场合；

- 写者优先：如果有写者，读者需要等待！用于更新频繁或更新影响显著的场合。

### 三、实验过程与结果

#### 1、实验思路

（1）首先根据题目意思可知，一个写者在向数据集写入数据的时候，与其他线程必须是互斥的，用互斥锁就可以实现；而读者线程在运行的时候，与写者线程互斥，但是与其他读者线程是可以同步的，所以不能用一个简单的互斥锁来解决，可以通过引入计数器的方法来实现。具体实现分为读者优先和写者优先两种情况。

（2）读者优先模式。读者线程运行时，用信号量sem控制同一时间只有一个读者线程控制读者计数器readercount，如果readercount大于0，即有读者读数据，则用互斥锁执行互斥操作，不让写者写数据，直到readercount=0，即所有读者线程都读完后，解开互斥锁，允许写操作执行。写操作执行时直接用互斥锁实现与其他线程互斥。

**读者优先模式代码：**

···bash
//读者优先时的写者控制函数
void *writerOfRF(void* in)
{
	while(1)
	{
		pthread_mutex_lock(&mutex_write);
		WriterCount++;
		printf("写线程id %d 进入程序\n当前等待读者数为%d，当前等待写者数为%d\n\n",pthread_self(),ReaderCount,WriterCount);
		Write();
		printf("写线程id %d 退出程序\n\n",pthread_self());
		WriterCount--;
		pthread_mutex_unlock(&mutex_write);
		sleep(W_sleep);
	}
	pthread_exit((void*)0);
}
//读者优先时的读者控制函数
void *readerOfRF(void* in)
{
	while(1)
	{
		sem_wait(&sem_readercount);
		ReaderCount++;
		printf("读线程id %d 进入程序\n当前等待读者数为%d，当前等待写者数为%d\n\n",pthread_self(),ReaderCount,WriterCount);
		if(ReaderCount == 1)
			pthread_mutex_lock(&mutex_write);
		sem_post(&sem_readercount);

		Read();

		sem_wait(&sem_readercount);
		ReaderCount--;
		printf("读线程id %d 退出程序\n\n",pthread_self());
		if(ReaderCount == 0)
			pthread_mutex_unlock(&mutex_write);
		sem_post(&sem_readercount);
		sleep(R_sleep);
	}
	pthread_exit((void*)0);
}
```

（3）写者优先模式。同读者优先模式，引入一个写者计数器writercount，用信号量sem控制同一时间只有一个写者线程控制写者计数器，如果writercount大于0，即还有写操作在执行，则不执行读操作，直到writercount=0。

**写者优先模式代码：**

```bahs
//写者优先时的写者控制函数
void *writerOfWF(void* in)
{
	while(1)
	{
		WriterCount++;
		if(WriterCount == 1)
			pthread_mutex_lock(&mutex_read);
		printf("写线程id %d 进入程序\n当前等待读者数为%d，当前等待写者数为%d\n\n",pthread_self(),ReaderCount,WriterCount);
		
		pthread_mutex_lock(&mutex_write);
		Write();
		pthread_mutex_unlock(&mutex_write);
		
		WriterCount--;
		if(WriterCount == 0)
			pthread_mutex_unlock(&mutex_read);
		printf("写线程id %d 退出程序\n\n",pthread_self());
		sleep(W_sleep);
	}
	pthread_exit((void*)0);
}

//写者优先时的读者控制函数
void *readerOfWF(void* in)
{
	while(1)
	{
		pthread_mutex_lock(&mutex_read);
		sem_wait(&sem_readercount);
		ReaderCount++;
		printf("读线程id %d 进入程序\n当前等待读者数为%d，当前等待写者数为%d\n\n",pthread_self(),ReaderCount,WriterCount);
		sem_post(&sem_readercount);
		pthread_mutex_unlock(&mutex_read);

		Read();

		sem_wait(&sem_readercount);
		ReaderCount--;
		printf("读线程id %d 退出程序\n\n",pthread_self());
		sem_post(&sem_readercount);
		sleep(R_sleep);
	}
	pthread_exit((void*)0);
}
```

#### 2、实验流程

实验流程图如下：

![process](https://github.com/SpursLipu/Embedded-software-development-technology-and-tools-/blob/master/coursework3/images/process.png)

#### 3、实验结果

1、读者优先结果

**读者优先运行结果图如下：**

![RFresult](https://github.com/SpursLipu/Embedded-software-development-technology-and-tools-/blob/master/coursework3/images/RFresult.png)

用户输入6个读者，3个写者，选择的是读者优先模式（0），从结果可以看出，程序先运行了6个读者线程，再开始运行3个写者线程，循环往复。与预期结果一致。

2、写者优先模式

**写者优先运行结果图如下：**

![WFresult](https://github.com/SpursLipu/Embedded-software-development-technology-and-tools-/blob/master/coursework3/images/WFresult.png)

用户输入6个读者，3个写者，选择的是写者优先模式（1），从结果看，确实是先运行了写者线程，再运行了读者线程。但是写者线程循环了两遍才开始运行读者线程，后续输出还有这种情况，也就是说并不是循环一遍读者就接着循环一遍写者，暂时不明白根本原因是什么。



### 四、实验总结

1、收获总结

- 深入了解了多线程同步技术：信号量、互斥锁，掌握了两种方法的基本应用；
- 对于多线程同步之间的逻辑关系与如何正确使用对应的同步技术有了较为深刻的理解；
- 小组成员相互纠正思维误区，一起解决了基本的知识点理解问题。

2、问题总结

- 由于个人对互斥锁应用的时候理解错误，结果输出时出现了卡顿，如下图。原因是把互斥锁理解成了锁共同资源，其实只是为了让写者进程与其他进程互斥，已改正。

![problem](https://github.com/SpursLipu/Embedded-software-development-technology-and-tools-/blob/master/coursework3/images/problem1.png)




### 五、实验源码

见Github仓库

https://github.com/SpursLipu/Embedded-software-development-technology-and-tools-/blob/master/coursework3/code/WriterReader.cpp
